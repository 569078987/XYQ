Cache-Control：
1 no-cache : 不直接使用缓存，始终向服务器发起请求

2 no-store : 禁止缓存任何响应，也就是说每次用户请求资源时，都会向服务器发送一个请求，每次都会下载完整的响应。

3 public ： 如果响应被标记为public，即使有关联的 HTTP 认证，甚至响应状态码无法正常缓存，响应也可以被缓存。

4 private : 浏览器可以缓存private响应，但是通常只为单个用户缓存，因此，不允许任何代理服务器对其进行缓存 。比如，用户浏览器可以缓存包含用户私人信息的 HTML 网页，但是 CDN 不能缓存。

5 max-age :  用来设置资源被缓存的最长时间(单位是秒)。


Etag: 客户端发送请求，服务端通过response header返回过来。 当客户端再次请求的时候 会将Etag通过if none match重新传给服务器。 （先比较文件修改时间是否一致）服务器根据 此时文件的etag做比较。相同则返回304， 不同则200


1.3 Last-Modified和Etag
从上面的解释可以看出，Cache-Control用于控制缓存和缓存时间，Last-Modified和Etag用于缓存过期时，与服务器做验证时使用，那么问题来了

有了Last-Modified为什么还需要Etag？
Last-Modified的值单位为秒。如果服务资源在1秒内发生多次变更，那服务器通过秒级对比就没办法发现文件是否已经变更。
一些特殊场景下，有些资源会被定时更新或者修改，但是其内容并未发生改变，而最后修改时间却在变化，导致客户端缓存定期失效，没有达到使用缓存的目的。
服务器可能因为一些其他原因，其时间没有与代理服务器或客户端时间保持一致，因时间偏差，从而导致缓存失效。
有了Etag为什么还需要Last-Modified？
Etag的值是服务器计算出的一串hash值，如果计算过程较复杂，比较消耗性能，那使用Last-Modified会比较合适
如果获取某些文件的最后修改时间比较容易，而文件的变更频率也不高，那无疑使用Last-Modified更合适
ETag比较的是响应内容的特征值，而Last-Modified 比较的是响应内容的修改时间。这两个是相辅相成的。服务器可以根据自己缓存机制的需要，选择ETag或者是Last-Modified来做缓存判断的依据，甚至可以两个同时参考。
Etag和Last-Modified同时存在时，服务器会优先判断Etag，如果Etag的值相同会继续判断Last-Modified，最后才决定是返回200还是304状态